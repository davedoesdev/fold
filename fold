#!/bin/bash
set -e

BRIDGE=weave
TAP_IFNAME=vethfotp$$
NFDHCP_BINDING_OUT="/var/lib/nfdhcpd/$TAP_IFNAME"
NFDHCP_CFG="/etc/nfdhcpd/nfdhcpd.conf"
MTU=16384 # max TAP MTU
HERE="$(dirname "$0")"

usage() {
    echo "Usage:"
    echo "fold [-4 <ipaddr>/<subnet>] [-6 <ip6prefix>] [-k <rdiscd-keyfile>] [-d <rdiscd-img-dir>] <nfdhcp-binding-file> <macaddr> kvm [<kvm args> ...]"
    exit 1
}

[ "$(id -u)" = 0 ] || {
    echo "fold must be run as 'root'" >&2
    exit 1
}

unset IPSUB PREFIX KEYFILE RDISCD_IMG_FILE
RDISCD_IMG_DIR=.
while getopts 4:6:k: opt
do
    case $opt in
        4)
            IPSUB="$OPTARG"
            ;;
        6)
            PREFIX="$OPTARG"
            ;;
        k)
            KEYFILE="$OPTARG"
            ;;
        d)
            RDISCD_IMG_DIR="$OPTARG"
            ;;
        *)
            usage
            ;;
    esac
done

shift $((OPTIND-1))

[ $# -gt 2 ] || usage

NFDHCP_BINDING_IN="$1"
MACADDR="$2"
COMMAND="$3"
shift 3

trim() {
    sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' "$@"
}

config() {
    grep -i "^$1 *=" $2 | sed 's/^[^=]*=//' | sed 's/#.*$//' | trim
}

config1() {
    config "$1" "$2" | sed 's/,.*$//' | trim
}

DHCP_QUEUE=$(config dhcp_queue "$NFDHCP_CFG")
RS_QUEUE=$(config rs_queue "$NFDHCP_CFG")
NS_QUEUE=$(config ns_queue "$NFDHCP_CFG")
DNS_QUEUE=$(config dns_queue "$NFDHCP_CFG")
DNS6_QUEUE=$(config dns6_queue "$NFDHCP_CFG")
NOTIFY_QUEUE=$(config notify_queue "$NFDHCP_CFG")
NOTIFY6_QUEUE=$(config notify6_queue "$NFDHCP_CFG")

if [ "$IPSUB" ]; then
    # extract the IP address from an ipaddr/subnet spec
    IFS=/ read -a ipsub <<< "$IPSUB"
    IPADDR="${ipsub[0]}"

    # make a zero-ending subnet mask (CIDR) from an ipaddr/subnet spec
    IFS=. read -a ipaddr <<< "$IPADDR"
    ipnum=$(((ipaddr[0] << 24) + (ipaddr[1] << 16) + (ipaddr[2] << 8) + (ipaddr[3])))
    ipnum=$((ipnum & ~(2 ** (32 - ipsub[1]) - 1)))
    SUBNET=$((ipnum >> 24 & 255)).$((ipnum >> 16 & 255)).$((ipnum >> 8 & 255)).$((ipnum & 255))/${ipsub[1]}
fi

if [ "$PREFIX" ]; then
    if [ "$KEYFILE" ]; then
        # For RFC-7217 (stable privacy addresses), support rdiscd.
        # We generate an address using rdiscd-mkaddress here and write it into
        # a disk image which we attach to the VM. rdiscd can then pick this up
        # in the guest. We could generate a random address here but it's nice
        # to be able to know which IPv6 address relates to a MAC address.
        IP6ADDR="$(rdiscd-mkaddress -m "$MACADDR" -k "$KEYFILE" "$PREFIX" stable-privacy)"
        RDISCD_IMG_FILE="$RDISCD_IMG_DIR/rdiscd_$TAP_IFNAME.img"
        genext2fs -b 1440 "$RDISCD_IMG_FILE"
        "$HERE/exp6" "$IP6ADDR" 16 8 | e2cp -P 400 - "$RDISCD_IMG_FILE:interface-id"
    else
        # Assume guest uses EUI-64.
        IP6ADDR="$("$HERE/exp6" "$PREFIX" 8):$("$HERE/eui-64" "$MACADDR")"
    fi
    # RFC-4941 (privacy extensions) aren't supported since we'd have no way
    # to tell nfdhcpd what to use when rewriting neighbour advertisement source
    # addresses. Also, allowing any VM to send/receive packets on any address
    # isn't desirable - we want to know a VM is only sending traffic on its
    # expected address (i.e. it's not impersonating another VM).
fi

unrule() {
    if iptables -t mangle -L "in$TAP_IFNAME" >& /dev/null; then
        iptables -t mangle -D PREROUTING -m physdev --physdev-in "$TAP_IFNAME" -j "in$TAP_IFNAME"
        iptables -t mangle -F "in$TAP_IFNAME"
        iptables -t mangle -X "in$TAP_IFNAME"
    fi
    if iptables -L "in$TAP_IFNAME" >& /dev/null; then
        iptables -D FORWARD -m physdev --physdev-in "$TAP_IFNAME" -j "in$TAP_IFNAME"
        iptables -F "in$TAP_IFNAME"
        iptables -X "in$TAP_IFNAME"
    fi
    if iptables -L "out$TAP_IFNAME" >& /dev/null; then
        iptables -D FORWARD -m physdev --physdev-is-bridged --physdev-out "$TAP_IFNAME" -j "out$TAP_IFNAME"
        iptables -F "out$TAP_IFNAME"
        iptables -X "out$TAP_IFNAME"
    fi
    if ip6tables -t mangle -L "in$TAP_IFNAME" >& /dev/null; then
        ip6tables -t mangle -D PREROUTING -m physdev --physdev-in "$TAP_IFNAME" -j "in$TAP_IFNAME"
        ip6tables -t mangle -F "in$TAP_IFNAME"
        ip6tables -t mangle -X "in$TAP_IFNAME"
    fi
    if ip6tables -L "in$TAP_IFNAME" >& /dev/null; then
        ip6tables -D FORWARD -m physdev --physdev-in "$TAP_IFNAME" -j "in$TAP_IFNAME"
        ip6tables -F "in$TAP_IFNAME"
        ip6tables -X "in$TAP_IFNAME"
    fi
    if ip6tables -L "out$TAP_IFNAME" >& /dev/null; then
        ip6tables -D FORWARD -m physdev --physdev-is-bridged --physdev-out "$TAP_IFNAME" -j "out$TAP_IFNAME"
        ip6tables -F "out$TAP_IFNAME"
        ip6tables -X "out$TAP_IFNAME"
    fi
    if ebtables -t nat -L "in$TAP_IFNAME" >& /dev/null; then
        ebtables -t nat -D PREROUTING -i "$TAP_IFNAME" -j "in$TAP_IFNAME"
        ebtables -t nat -F "in$TAP_IFNAME"
        ebtables -t nat -X "in$TAP_IFNAME"
    fi
    if ebtables -L "in$TAP_IFNAME" >& /dev/null; then
        ebtables -D FORWARD -i "$TAP_IFNAME" -j "in$TAP_IFNAME"
        ebtables -F "in$TAP_IFNAME"
        ebtables -X "in$TAP_IFNAME"
    fi
    if ebtables -L "out$TAP_IFNAME" >& /dev/null; then
        ebtables -D FORWARD -o "$TAP_IFNAME" -j "out$TAP_IFNAME"
        ebtables -F "out$TAP_IFNAME"
        ebtables -X "out$TAP_IFNAME"
    fi
}

rule() {
    if [ "$IPSUB" ]; then
        iptables -t mangle -N "in$TAP_IFNAME"
        iptables -t mangle -A PREROUTING -m physdev --physdev-in "$TAP_IFNAME" -j "in$TAP_IFNAME"
        iptables -t mangle -A "in$TAP_IFNAME" -p udp --dport bootps -j NFQUEUE --queue-num "$DHCP_QUEUE"
        iptables -t mangle -A "in$TAP_IFNAME" -p udp --dport domain -j NFQUEUE --queue-num "$DNS_QUEUE"
        #iptables -t mangle -L

        iptables -N "in$TAP_IFNAME"
        iptables -A FORWARD -m physdev --physdev-in "$TAP_IFNAME" -j "in$TAP_IFNAME"
        iptables -A "in$TAP_IFNAME" -s "$IPADDR" -d "$SUBNET" -j ACCEPT
        iptables -A "in$TAP_IFNAME" -j REJECT

        iptables -N "out$TAP_IFNAME"
        iptables -A FORWARD -m physdev --physdev-is-bridged --physdev-out "$TAP_IFNAME" -j "out$TAP_IFNAME"
        iptables -A "out$TAP_IFNAME" -s "$SUBNET" -d "$IPADDR" -j ACCEPT
        iptables -A "out$TAP_IFNAME" -j REJECT
        #iptables -L

        ebtables -t nat -N "in$TAP_IFNAME" -P RETURN
        ebtables -t nat -A PREROUTING -i "$TAP_IFNAME" -j "in$TAP_IFNAME"
        ebtables -t nat -A "in$TAP_IFNAME" -p arp --arp-opcode request --arp-ip-dst "$(config1 nameservers "$NFDHCP_BINDING_IN")" -j arpreply --arpreply-mac "$MACADDR"
        #ebtables -t nat -L
    fi

    if [ "$PREFIX" ]; then
        ip6tables -t mangle -N "in$TAP_IFNAME"
        ip6tables -t mangle -A PREROUTING -m physdev --physdev-in "$TAP_IFNAME" -j "in$TAP_IFNAME"
        ip6tables -t mangle -A "in$TAP_IFNAME" -p udp --dport domain -j NFQUEUE --queue-num "$DNS6_QUEUE"
        ip6tables -t mangle -A "in$TAP_IFNAME" -p ipv6-icmp --icmpv6-type router-solicitation -j NFQUEUE --queue-num "$RS_QUEUE"
        ip6tables -t mangle -A "in$TAP_IFNAME" -p ipv6-icmp --icmpv6-type neighbour-solicitation -j NFQUEUE --queue-num "$NS_QUEUE"
        #ip6tables -t mangle -L

        ip6tables -N "in$TAP_IFNAME"
        ip6tables -A FORWARD -m physdev --physdev-in "$TAP_IFNAME" -j "in$TAP_IFNAME"
        ip6tables -A "in$TAP_IFNAME" -s "$IP6ADDR" -d "$PREFIX" -j ACCEPT
        # Allow packets to solicited-node multicast addresses (for neighbour
        # solicitations). nfdhcpd checks if the request is for the allocated
        # prefix (and only intercepts if it's not). nfdhcp also sets the source
        # address to the non-link local address.
        # Note that we expect neighbour advertisements to have non-link local
        # source and destination.
        ip6tables -A "in$TAP_IFNAME" -s "$IP6ADDR" -d ff02:0:0:0:0:1:ff00::/104 -p ipv6-icmp --icmpv6-type neighbour-solicitation -j ACCEPT
        ip6tables -A "in$TAP_IFNAME" -j REJECT

        ip6tables -N "out$TAP_IFNAME"
        ip6tables -A FORWARD -m physdev --physdev-is-bridged --physdev-out "$TAP_IFNAME" -j "out$TAP_IFNAME"
        ip6tables -A "out$TAP_IFNAME" -s "$PREFIX" -d "$IP6ADDR" -j ACCEPT
        # Allow packets to our solicited-node multicast address (for neighbour
        # solicitations).
        # Note that we expect neighbour advertisements to have non-link local
        # source and destination.
        ip6tables -A "out$TAP_IFNAME" -s "$PREFIX" -d "$("$HERE/solip6" "$IP6ADDR")" -p ipv6-icmp --icmpv6-type neighbour-solicitation -j ACCEPT
        ip6tables -A "out$TAP_IFNAME" -j REJECT
        #ip6tables -L
    fi

    NOTIFY_PORT="$(config notify_port "$NFDHCP_BINDING_IN")"
    if [ "$NOTIFY_PORT" ]; then
        if [ "$IPSUB" ]; then
            NOTIFY_IP="$(config notify_ip "$NFDHCP_BINDING_IN")"
            if [ "$NOTIFY_IP" ]; then
                iptables -t mangle -A "in$TAP_IFNAME" -p udp -d "$NOTIFY_IP" --dport "$NOTIFY_PORT" -j NFQUEUE --queue-num "$NOTIFY_QUEUE"
                iptables -t mangle -A "in$TAP_IFNAME" -p udp --dport "$NOTIFY_PORT" -j DROP
                iptables -t mangle -A "in$TAP_IFNAME" -p tcp --dport "$NOTIFY_PORT" -j DROP
                iptables -I "out$TAP_IFNAME" -p udp --dport "$NOTIFY_PORT" -j REJECT
                iptables -I "out$TAP_IFNAME" -p tcp --dport "$NOTIFY_PORT" -j REJECT
                ebtables -t nat -A "in$TAP_IFNAME" -p arp --arp-opcode request --arp-ip-dst "$NOTIFY_IP" -j arpreply --arpreply-mac "$MACADDR"
            fi
        fi
        if [ "$PREFIX" ]; then
            NOTIFY_IP6="$(config notify_ip6 "$NFDHCP_BINDING_IN")"
            if [ "$NOTIFY_IP6" ]; then
                ip6tables -t mangle -A "in$TAP_IFNAME" -p udp -d "$NOTIFY_IP6" --dport "$NOTIFY_PORT" -j NFQUEUE --queue-num "$NOTIFY6_QUEUE"
                ip6tables -t mangle -A "in$TAP_IFNAME" -p udp --dport "$NOTIFY_PORT" -j DROP
                ip6tables -t mangle -A "in$TAP_IFNAME" -p tcp --dport "$NOTIFY_PORT" -j DROP
                ip6tables -I "out$TAP_IFNAME" -p udp --dport "$NOTIFY_PORT" -j REJECT
                ip6tables -I "out$TAP_IFNAME" -p tcp --dport "$NOTIFY_PORT" -j REJECT
            fi
        fi
    fi

    ebtables -N "in$TAP_IFNAME" -P DROP
    ebtables -A FORWARD -i "$TAP_IFNAME" -j "in$TAP_IFNAME"
    # Stop any packets not from allocated MAC address
    ebtables -A "in$TAP_IFNAME" -s ! "$MACADDR" -j DROP
    if [ "$IPSUB" ]; then
        # Allow ARP packets from this IP address to subnet
        ebtables -A "in$TAP_IFNAME" -p arp --arp-ip-src "$IPADDR" --arp-ip-dst "$SUBNET" -j ACCEPT
        # Allow IPv4
        ebtables -A "in$TAP_IFNAME" -p ipv4 -j ACCEPT
    fi
    if [ "$PREFIX" ]; then
        # Allow IPv6
        ebtables -A "in$TAP_IFNAME" -p ipv6 -j ACCEPT
    fi

    ebtables -N "out$TAP_IFNAME" -P DROP
    ebtables -A FORWARD -o "$TAP_IFNAME" -j "out$TAP_IFNAME"
    if [ "$IPSUB" ]; then
        # Allow ARP requests for this IP address from subnet
        ebtables -A "out$TAP_IFNAME" -p arp --arp-opcode request --arp-ip-src "$SUBNET" --arp-ip-dst "$IPADDR" -j ACCEPT
    fi
    if [ "$PREFIX" ]; then
        # Allow solicited-node multicast requests
        ebtables -A "out$TAP_IFNAME" -d "$("$HERE/solmac" "$IP6ADDR")" -j ACCEPT
    fi
    # Stop any packets not for allocated MAC address
    ebtables -A "out$TAP_IFNAME" -d ! "$MACADDR" -j DROP
    if [ "$IPSUB" ]; then
        # Allow ARP replies to this IP address but only from subnet
        ebtables -A "out$TAP_IFNAME" -p arp --arp-opcode reply --arp-ip-src "$SUBNET" --arp-ip-dst "$IPADDR" -j ACCEPT
        # Allow IPv4
        ebtables -A "out$TAP_IFNAME" -p ipv4 -j ACCEPT
    fi
    if [ "$PREFIX" ]; then
        # Allow IPv6
        ebtables -A "out$TAP_IFNAME" -p ipv6 -j ACCEPT
    fi

    #ebtables -L
}

untap() {
    if ip link show dev "$TAP_IFNAME" >& /dev/null; then
         ip link del dev "$TAP_IFNAME"
    fi
}

tap() {
    ip tuntap add dev "$TAP_IFNAME" mode tap
    ip link set dev "$TAP_IFNAME" mtu "$MTU"
    ip link set dev "$TAP_IFNAME" master "$BRIDGE"
    ip link set dev "$TAP_IFNAME" up
}

cleanup() {
    untap; unrule
    rm -f "$NFDHCP_BINDING_OUT"
    [ "$RDISCD_IMG_FILE" ] && rm -f "$RDISCD_IMG_FILE"
}

trap cleanup EXIT

unrule; rule
untap; tap

( echo "MAC=$MACADDR"
  [ "$IPADDR" ] && echo "IP=$IPADDR"
  [ "$SUBNET" ] && echo "SUBNET=$SUBNET"
  [ "$PREFIX" ] && echo "SUBNET6=$PREFIX"
  [ "$IP6ADDR" ] && echo "IP6=$IP6ADDR"
  echo "MTU=$MTU"
  cat "$NFDHCP_BINDING_IN" )  > "$NFDHCP_BINDING_OUT"

case "$COMMAND" in
    kvm)
# rdiscd support: permissions (do we care?), test with rdiscd in guest - automount disk in guest
# xen, capstan support
# make examples in nfdhcpd README much shorter and point to fold
# network goes down every so often

        kvm -netdev "tap,id=hn0,ifname=$TAP_IFNAME,script=no,downscript=no" -device "virtio-net-pci,netdev=hn0,id=nic1,mac=$MACADDR" "${@//\[rdisk_img_file\]/$RDISCD_IMG_FILE}"
        ;;
    *)
        echo "Unknown fold command '$COMMAND'" >&2
        usage
        ;;
esac

