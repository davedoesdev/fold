#!/bin/bash
set -e

BRIDGE=weave
TAP_IFNAME=vethfotp$$
NFDHCP_BINDING_OUT="/var/lib/nfdhcpd/$TAP_IFNAME"
NFDHCP_CFG="/etc/nfdhcpd/nfdhcpd.conf"
MTU=16384 # max TAP MTU
HERE="$(dirname "$0")"

usage() {
    echo "Usage:"
    echo "fold [-4 <ipaddr>/<subnet>] [-6 <ip6prefix>] <nfdhcp-binding-file> <macaddr> kvm [<kvm args> ...]"
    exit 1
}

[ "$(id -u)" = 0 ] || {
    echo "fold must be run as 'root'" >&2
    exit 1
}

while getopts 4:6: opt
do
    case $opt in
        4)
            IPSUB="$OPTARG"
            ;;
        6)
            PREFIX="$OPTARG"
            ;;
        *)
            usage
            ;;
    esac
done

shift $((OPTIND-1))

[ $# -gt 2 ] || usage

NFDHCP_BINDING_IN="$1"
MACADDR="$2"
COMMAND="$3"
shift 3

trim() {
    sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' "$@"
}

config() {
    grep -i "^$1 *=" $2 | sed 's/^[^=]*=//' | sed 's/#.*$//' | trim
}

config1() {
    config "$1" "$2" | sed 's/,.*$//' | trim
}

DHCP_QUEUE=$(config dhcp_queue "$NFDHCP_CFG")
RS_QUEUE=$(config rs_queue "$NFDHCP_CFG")
NS_QUEUE=$(config ns_queue "$NFDHCP_CFG")
DNS_QUEUE=$(config dns_queue "$NFDHCP_CFG")
DNS6_QUEUE=$(config dns6_queue "$NFDHCP_CFG")
NOTIFY_QUEUE=$(config notify_queue "$NFDHCP_CFG")
NOTIFY6_QUEUE=$(config notify6_queue "$NFDHCP_CFG")

if [ "$IPSUB" ]; then
    # extract the IP address from an ipaddr/subnet spec
    IFS=/ read -a ipsub <<< "$IPSUB"
    IPADDR="${ipsub[0]}"

    # make a zero-ending subnet mask (CIDR) from an ipaddr/subnet spec
    IFS=. read -a ipaddr <<< "$IPADDR"
    ipnum=$(((ipaddr[0] << 24) + (ipaddr[1] << 16) + (ipaddr[2] << 8) + (ipaddr[3])))
    ipnum=$((ipnum & ~(2 ** (32 - ipsub[1]) - 1)))
    SUBNET=$((ipnum >> 24 & 255)).$((ipnum >> 16 & 255)).$((ipnum >> 8 & 255)).$((ipnum & 255))/${ipsub[1]}
fi

if [ "$PREFIX" ]; then
    # Assume guest uses EUI-64.
    # For RFC-4941 (privacy extensions) we should use IP6ADDR="$PREFIX"
    # For RFC-7217 (stable privacy addresses) we should use rdiscd-mkaddress
    IP6ADDR="$(python -c "import socket, binascii, sys; sys.stdout.write(binascii.hexlify(socket.inet_pton(socket.AF_INET6, '$(echo "$PREFIX" | sed 's/\/.*//')'))[:16])" | sed 's/\(.\{4\}\)/\1:/g')$("$HERE/eui-64" "$MACADDR")"
fi

unrule() {
    if iptables -t mangle -L "in$TAP_IFNAME" >& /dev/null; then
        iptables -t mangle -D PREROUTING -m physdev --physdev-in "$TAP_IFNAME" -j "in$TAP_IFNAME"
        iptables -t mangle -F "in$TAP_IFNAME"
        iptables -t mangle -X "in$TAP_IFNAME"
    fi
    if iptables -L "in$TAP_IFNAME" >& /dev/null; then
        iptables -D FORWARD -m physdev --physdev-in "$TAP_IFNAME" -j "in$TAP_IFNAME"
        iptables -F "in$TAP_IFNAME"
        iptables -X "in$TAP_IFNAME"
    fi
    if iptables -L "out$TAP_IFNAME" >& /dev/null; then
        iptables -D FORWARD -m physdev --physdev-is-bridged --physdev-out "$TAP_IFNAME" -j "out$TAP_IFNAME"
        iptables -F "out$TAP_IFNAME"
        iptables -X "out$TAP_IFNAME"
    fi
    if ip6tables -t mangle -L "in$TAP_IFNAME" >& /dev/null; then
        ip6tables -t mangle -D PREROUTING -m physdev --physdev-in "$TAP_IFNAME" -j "in$TAP_IFNAME"
        ip6tables -t mangle -F "in$TAP_IFNAME"
        ip6tables -t mangle -X "in$TAP_IFNAME"
    fi
    if ip6tables -L "in$TAP_IFNAME" >& /dev/null; then
        ip6tables -D FORWARD -m physdev --physdev-in "$TAP_IFNAME" -j "in$TAP_IFNAME"
        ip6tables -F "in$TAP_IFNAME"
        ip6tables -X "in$TAP_IFNAME"
    fi
    if ip6tables -L "out$TAP_IFNAME" >& /dev/null; then
        ip6tables -D FORWARD -m physdev --physdev-is-bridged --physdev-out "$TAP_IFNAME" -j "out$TAP_IFNAME"
        ip6tables -F "out$TAP_IFNAME"
        ip6tables -X "out$TAP_IFNAME"
    fi
    if ebtables -t nat -L "in$TAP_IFNAME" >& /dev/null; then
        ebtables -t nat -D PREROUTING -i "$TAP_IFNAME" -j "in$TAP_IFNAME"
        ebtables -t nat -F "in$TAP_IFNAME"
        ebtables -t nat -X "in$TAP_IFNAME"
    fi
    if ebtables -L "in$TAP_IFNAME" >& /dev/null; then
        ebtables -D FORWARD -i "$TAP_IFNAME" -j "in$TAP_IFNAME"
        ebtables -F "in$TAP_IFNAME"
        ebtables -X "in$TAP_IFNAME"
    fi
    if ebtables -L "out$TAP_IFNAME" >& /dev/null; then
        ebtables -D FORWARD -o "$TAP_IFNAME" -j "out$TAP_IFNAME"
        ebtables -F "out$TAP_IFNAME"
        ebtables -X "out$TAP_IFNAME"
    fi
}

rule() {
    if [ "$IPSUB" ]; then
        iptables -t mangle -N "in$TAP_IFNAME"
        iptables -t mangle -A PREROUTING -m physdev --physdev-in "$TAP_IFNAME" -j "in$TAP_IFNAME"
        iptables -t mangle -A "in$TAP_IFNAME" -p udp --dport bootps -j NFQUEUE --queue-num "$DHCP_QUEUE"
        iptables -t mangle -A "in$TAP_IFNAME" -p udp --dport domain -j NFQUEUE --queue-num "$DNS_QUEUE"
        #iptables -t mangle -L

        iptables -N "in$TAP_IFNAME"
        iptables -A FORWARD -m physdev --physdev-in "$TAP_IFNAME" -j "in$TAP_IFNAME"
        iptables -A "in$TAP_IFNAME" -s "$IPADDR" -d "$SUBNET" -j ACCEPT
        iptables -A "in$TAP_IFNAME" -j REJECT

        iptables -N "out$TAP_IFNAME"
        iptables -A FORWARD -m physdev --physdev-is-bridged --physdev-out "$TAP_IFNAME" -j "out$TAP_IFNAME"
        iptables -A "out$TAP_IFNAME" -s "$SUBNET" -d "$IPADDR" -j ACCEPT
        iptables -A "out$TAP_IFNAME" -j REJECT
        #iptables -L

        ebtables -t nat -N "in$TAP_IFNAME" -P RETURN
        ebtables -t nat -A PREROUTING -i "$TAP_IFNAME" -j "in$TAP_IFNAME"
        ebtables -t nat -A "in$TAP_IFNAME" -p arp --arp-opcode request --arp-ip-dst "$(config1 nameservers "$NFDHCP_BINDING_IN")" -j arpreply --arpreply-mac "$MACADDR"
        #ebtables -t nat -L
    fi

    if [ "$PREFIX" ]; then
        ip6tables -t mangle -N "in$TAP_IFNAME"
        ip6tables -t mangle -A PREROUTING -m physdev --physdev-in "$TAP_IFNAME" -j "in$TAP_IFNAME"
        ip6tables -t mangle -A "in$TAP_IFNAME" -p udp --dport domain -j NFQUEUE --queue-num "$DNS6_QUEUE"
        ip6tables -t mangle -A "in$TAP_IFNAME" -p ipv6-icmp --icmpv6-type router-solicitation -j NFQUEUE --queue-num "$RS_QUEUE"
        ip6tables -t mangle -A "in$TAP_IFNAME" -p ipv6-icmp --icmpv6-type neighbour-solicitation -j NFQUEUE --queue-num "$NS_QUEUE"
        #ip6tables -t mangle -L

        ip6tables -N "in$TAP_IFNAME"
        ip6tables -A FORWARD -m physdev --physdev-in "$TAP_IFNAME" -j "in$TAP_IFNAME"
        ip6tables -A "in$TAP_IFNAME" -s "$IP6ADDR" -d "$PREFIX" -j ACCEPT
        # Allow packets to solicited-node multicast addresses (for neighbour solicitation)
        # nfdhcpd checks if the request is for the allocated prefix (and only intercepts if it's not)
        ip6tables -A "in$TAP_IFNAME" -s "$IP6ADDR" -d "$("$HERE/solip6" "$IPADDR")" -j ACCEPT
        ###ip6tables -A "in$TAP_IFNAME" -j REJECT

        ip6tables -N "out$TAP_IFNAME"
        ip6tables -A FORWARD -m physdev --physdev-is-bridged --physdev-out "$TAP_IFNAME" -j "out$TAP_IFNAME"
        ip6tables -A "out$TAP_IFNAME" -s "$PREFIX" -d "$IP6ADDR" -j ACCEPT
        ###ip6tables -A "out$TAP_IFNAME" -j REJECT
        #ip6tables -L
    fi

    ebtables -N "in$TAP_IFNAME" -P DROP
    ebtables -A FORWARD -i "$TAP_IFNAME" -j "in$TAP_IFNAME"
    # Stop any packets not from allocated MAC address
    ebtables -A "in$TAP_IFNAME" -s ! "$MACADDR" -j DROP
    if [ "$IPSUB" ]; then
        # Allow ARP packets from this IP address to subnet
        ebtables -A "in$TAP_IFNAME" -p arp --arp-ip-src "$IPADDR" --arp-ip-dst "$SUBNET" -j ACCEPT
        # Allow IPv4
        ebtables -A "in$TAP_IFNAME" -p ipv4 -j ACCEPT
    fi
    if [ "$PREFIX" ]; then
        # Allow IPv6
        ebtables -A "in$TAP_IFNAME" -p ipv6 -j ACCEPT
    fi

    ebtables -N "out$TAP_IFNAME" -P DROP
    ebtables -A FORWARD -o "$TAP_IFNAME" -j "out$TAP_IFNAME"
    if [ "$IPSUB" ]; then
        # Allow ARP requests for this IP address from subnet
        ebtables -A "out$TAP_IFNAME" -p arp --arp-opcode request --arp-ip-src "$SUBNET" --arp-ip-dst "$IPADDR" -j ACCEPT
    fi
    if [ "$PREFIX" ]; then
        # Allow solicited-node multicast requests
        ebtables -A "out$TAP_IFNAME" -d "$("$HERE/solmac" "$IPADDR") -j ACCEPT
    fi
    # Stop any packets not for allocated MAC address
    ebtables -A "out$TAP_IFNAME" -d ! "$MACADDR" -j DROP
    if [ "$IPSUB" ]; then
        # Allow ARP replies to this IP address but only from subnet
        ebtables -A "out$TAP_IFNAME" -p arp --arp-opcode reply --arp-ip-src "$SUBNET" --arp-ip-dst "$IPADDR" -j ACCEPT
        # Allow IPv4
        ebtables -A "out$TAP_IFNAME" -p ipv4 -j ACCEPT
    fi
    if [ "$PREFIX" ]; then
        # Allow IPv6
        ebtables -A "out$TAP_IFNAME" -p ipv6 -j ACCEPT
    fi

    #ebtables -L
}

untap() {
    if ip link show dev "$TAP_IFNAME" >& /dev/null; then
         ip link del dev "$TAP_IFNAME"
    fi
}

tap() {
    ip tuntap add dev "$TAP_IFNAME" mode tap
    ip link set dev "$TAP_IFNAME" mtu "$MTU"
    ip link set dev "$TAP_IFNAME" master "$BRIDGE"
    ip link set dev "$TAP_IFNAME" up
}

cleanup() {
    untap; unrule
    rm -f "$NFDHCP_BINDING_OUT"
}

trap cleanup EXIT

unrule; rule
untap; tap

( echo "MAC=$MACADDR"
  [ "$IPADDR" ] && echo "IP=$IPADDR"
  [ "$SUBNET" ] && echo "SUBNET=$SUBNET"
  [ "$PREFIX" ] && echo "SUBNET6=$PREFIX"
  echo "MTU=$MTU"
  cat "$NFDHCP_BINDING_IN" )  > "$NFDHCP_BINDING_OUT"

case "$COMMAND" in
    kvm)

# can we ping link local addresses? find out if switch should route them - as weave is an ethernet switch it probably shouldn't. even if we could, it means we couldn't restrict traffic based on prefix. so we should check we CAN'T ping local link addresses
# neighbour solicitation address - do we need FORWARD and mangle rules for other direction? otherwise won't get through
# need rule to put notify messages on queue
# stop notify messages (on that port) going in/out and test notification; is it sending them now?
# network goes down every so often

        # make examples in nfdhcpd README much shorter and point to fold

        kvm -netdev "tap,id=hn0,ifname=$TAP_IFNAME,script=no,downscript=no" -device "virtio-net-pci,netdev=hn0,id=nic1,mac=$MACADDR" "$@"
        ;;
    *)
        echo "Unknown fold command '$COMMAND'" >&2
        usage
        ;;
esac

